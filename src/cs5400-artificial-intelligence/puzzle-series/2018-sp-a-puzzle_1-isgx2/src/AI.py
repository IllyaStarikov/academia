#!/usr/local/bin/python3
#
# AI.py
# puzzle-assignment
#
# Created by Illya Starikov on 01/27/18.
# Copyright 2018. Illya Starikov. All rights reserved.
#

from search_node import SearchNode
from mechanical_match import MechanicalMatch

from collections import deque
from logger import logger, LogPriority


class AI():
    def __init__(self, game):
        """Just sets the game up."""
        self.game = game
        self.max_score = 0

    def log_progress(self, node):
        """Logs the current progress of the game.

        Args:
            node (SearchNode): The current search node
        """
        self.max_score = max(self.max_score, node.state.points)
        logger.log(self.max_score, LogPriority.PROGRESS)

    def breadth_first_tree_search(self):
        """Does a BFS search on the game state.

        Returns:
            SearchNode: The node that the solution was found in.
        """

        node = SearchNode(self.game.initial_state, None, None, 1)
        self.max_score = 0

        if MechanicalMatch.goal_test(node.state, self.game.quota):
            return self.solution(node)

        frontier = deque([node])

        while len(frontier) > 0:
            node = frontier.popleft()

            for action in MechanicalMatch.actions(node.state):
                child = self.child_node(node.state, node, action)
                self.log_progress(child)

                if MechanicalMatch.goal_test(child.state, self.game.quota):
                    return self.solution(child)

                frontier.append(child)

    @staticmethod
    def child_node(state, parent, action):
        """Generates a child node based on the current state, and the action to take.

        Args:
            state (State): The current state of the game.
            parent (SearchNode): The parent of the returned child node.
            action (Action): The action to take to generate the child.

        Returns:
            SearchNode: The node generated by applying action onto the state.
        """
        state = MechanicalMatch.result(state, action)
        cost = parent.path_cost + MechanicalMatch.path_cost(state, action)

        return SearchNode(state, action, parent, cost)

    @staticmethod
    def solution(node):
        """A function to call when a solution has been found.

        Args:
            node (SearchNode): The node where the solution was found.

        Returns:
            SearchNode: Returns the node passed
        """

        return node
