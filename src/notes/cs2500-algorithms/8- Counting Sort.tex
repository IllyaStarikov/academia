\documentclass{article}
\begin{document}

\setcounter{section}{7}
\section{Counting Sort Algorithm}
\begin{itemize}
    \item We have talked about many algorithms so far
    \begin{description}
        \item [Insertion Sort] Worst: $\Theta(n^2)$, Average: $
        \Theta(n^2)$
        \item [Merge Sort] Worst: $\Theta(n \lg n)$, Average: $
        \Theta(n \lg n)$
        \item [Quick Sort] Worst: $\Theta(n^2)$, Average: $
        \Theta(n \lg n)$
        \item [Heap Sort] Worst: $\Theta(n \lg n)$, Average: $
        \Theta(n \lg n)$
    \end{description}
    \item Most of the basic operations have been so far is comparison.
    \item Merge sort is asymptotically optimal (in general).
    \item Any comparison based sorting is bounded $\Omega (n \lg n)$
    \item Is there any way to sort in linear time?
    \begin{itemize}
        \item Counting Sort is a way to achieve this.
    \end{itemize}
\end{itemize}

\subsection{Counting Sort}
 We want to sort integers. [$0 \ldots k$], where $k$ is max in the array.

\begin{enumerate}
    \item Count the number of each distinct elements (frequency).
    \item Determine the position of each element by placing it to the ``counting index''.
\end{enumerate}

Specifically,

\begin{enumerate}
    \item Specifically, given array of size $n$, and the maximum integer in the array is $k$.
    \item Create ``counting array'', whose size is $k + 1$.
    \item Fill the counting array with the frequency of each element.
    \item Update the counting array accumulatively adding up frequencies
    \item Place our numbers in the position of ``accumulated numbers''.
\end{enumerate}

\subsubsection{Example}
\begin{verbatim}
Given Array: [1 3 0 2 4 3 1]
Size: 7
Max: 4

Counting array (size of k+1): [1 | 2 | 1 | 2 | 1]
Notice how the indexes are how how many times the number appears in original array

Update: [1 3 4 6 7]
These are the updated positions of the array elements

Enumerated Steps
Output: [ | | 1 | | | |]
Now deincrement updated array. ([1 2 4 6 7])

Output: [ | | 1 | | | 3 |] ([1 2 4 5 7])
Output: [ | | 1 | | | 3 | 4] ([1 2 4 5 6])
So on and so forth.
\end{verbatim}

\subsubsection{Psuedocode}
Let $A$ = input array, $B$ = output array, $n$ = size of array, $k$ = maximum number.
\begin{verbatim}
countingSort(A, B, n, k)
    let C[0...k] be the counting array
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    for j = n down to 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1
\end{verbatim}

We can see that the complexity is $\Theta(n+k)$
\end{document}